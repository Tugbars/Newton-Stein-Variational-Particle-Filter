/**
 * @file test_svpf_gradient_market.cu
 * @brief Gradient diagnostic on REAL market data
 *
 * Purpose: Verify ν gradient behavior on actual market crashes where
 *          the DGP synthetic scenarios showed insufficient tail events.
 *
 * Key hypothesis:
 *   - Real crashes (2008, 2020) have genuine fat tails
 *   - ν gradient should be much more informative during these periods
 *   - Equilibrium ν should be lower than on synthetic data
 *
 * Data files (generated by scripts/fetch_market_data.py):
 *   - market_data/spy_full.bin          (4528 obs, 2007-2024)
 *   - market_data/spy_2008_crisis.bin   (375 obs)
 *   - market_data/spy_2020_covid.bin    (123 obs)
 *   - market_data/crashes_combined.bin  (706 obs, all crash periods)
 */

#include "svpf.cuh"
#include "market_data_loader.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

/*═══════════════════════════════════════════════════════════════════════════
 * CONFIGURATION
 *═══════════════════════════════════════════════════════════════════════════*/

// Try multiple paths for market data
static const char* DATA_PATHS[] = {
    "../market_data/",           // From build/ directory
    "market_data/",              // From project root
    "../../market_data/",        // From build/Release or build/Debug
    "../../../market_data/",     // Deeper nested build dirs
    NULL
};

// Default filter configuration
#define DEFAULT_PARTICLES    4096
#define DEFAULT_STEIN_STEPS  5

// Find the correct data path
static const char* find_data_path(void) {
    for (int i = 0; DATA_PATHS[i] != NULL; i++) {
        char test_path[512];
        snprintf(test_path, sizeof(test_path), "%sspy_full.bin", DATA_PATHS[i]);
        FILE* f = fopen(test_path, "rb");
        if (f) {
            fclose(f);
            return DATA_PATHS[i];
        }
    }
    return NULL;
}

/*═══════════════════════════════════════════════════════════════════════════
 * MOMENT-MATCHING CALIBRATION
 *═══════════════════════════════════════════════════════════════════════════*/

/**
 * @brief Estimate μ from realized volatility (moment matching)
 * 
 * In the SV model: vol_t = exp(h_t/2), with E[h_t] = μ
 * So: E[vol] ≈ exp(μ/2)  →  μ ≈ 2·log(realized_vol)
 * 
 * This is crude but gets μ within ~10-20% of PMMH estimate,
 * which is sufficient for the gradient diagnostic.
 */
static float estimate_mu_from_data(const float* returns, int n) {
    // Compute sample variance
    double sum = 0, sq_sum = 0;
    for (int i = 0; i < n; i++) {
        sum += returns[i];
        sq_sum += returns[i] * returns[i];
    }
    double mean = sum / n;
    double var = sq_sum / n - mean * mean;
    
    // Sample std = proxy for unconditional volatility
    float realized_vol = sqrtf((float)var);
    
    // μ = 2·log(vol) since vol = exp(h/2)
    return 2.0f * logf(realized_vol + 1e-8f);
}

/*═══════════════════════════════════════════════════════════════════════════
 * TEST UTILITIES
 *═══════════════════════════════════════════════════════════════════════════*/

typedef struct {
    float mean_gradient;
    float mean_z_sq;
    int n_crashes;          // z² > 9
    float mean_grad_crash;  // Gradient during crashes
    float mean_grad_calm;   // Gradient during calm
    float rmse_vol;         // RMSE vs realized vol
    int n_obs;
} GradientStats;

static GradientStats run_gradient_test(
    const float* returns,
    int n,
    float filter_nu,
    float filter_mu,
    float filter_rho,
    float filter_sigma_z,
    int n_particles,
    int n_stein_steps
) {
    GradientStats stats = {0};
    stats.n_obs = n;
    
    // Create filter
    SVPFState* state = svpf_create(n_particles, n_stein_steps, filter_nu, nullptr);
    SVPFParams params = {filter_rho, filter_sigma_z, filter_mu, 0.0f};
    svpf_initialize(state, &params, 12345);
    
    // Accumulators
    double grad_sum = 0, z_sq_sum = 0;
    double grad_crash_sum = 0, grad_calm_sum = 0;
    int n_crash = 0, n_calm = 0;
    double vol_sq_err_sum = 0;
    
    // Estimate realized vol with EMA
    float realized_vol = fabsf(returns[0]);
    const float vol_ema_alpha = 0.1f;
    
    float y_prev = 0.0f;
    for (int t = 0; t < n; t++) {
        float y_t = returns[t];
        
        // Update realized vol estimate
        realized_vol = (1.0f - vol_ema_alpha) * realized_vol + vol_ema_alpha * fabsf(y_t);
        
        // SVPF step
        float loglik, vol_est, h_mean;
        svpf_step_graph(state, y_t, y_prev, &params, &loglik, &vol_est, &h_mean);
        
        // Gradient diagnostic
        float nu_grad, z_sq;
        svpf_compute_nu_diagnostic_simple(state, y_t, &nu_grad, &z_sq);
        
        // Accumulate
        if (!isnan(nu_grad) && !isinf(nu_grad)) {
            grad_sum += nu_grad;
            z_sq_sum += z_sq;
            
            if (z_sq > 9.0f) {
                grad_crash_sum += nu_grad;
                n_crash++;
            } else {
                grad_calm_sum += nu_grad;
                n_calm++;
            }
        }
        
        // Vol error
        float vol_err = vol_est - realized_vol;
        vol_sq_err_sum += vol_err * vol_err;
        
        y_prev = y_t;
    }
    
    svpf_destroy(state);
    
    // Compute stats
    stats.mean_gradient = (float)(grad_sum / n);
    stats.mean_z_sq = (float)(z_sq_sum / n);
    stats.n_crashes = n_crash;
    stats.mean_grad_crash = (n_crash > 0) ? (float)(grad_crash_sum / n_crash) : 0.0f;
    stats.mean_grad_calm = (n_calm > 0) ? (float)(grad_calm_sum / n_calm) : 0.0f;
    stats.rmse_vol = sqrtf((float)(vol_sq_err_sum / n));
    
    return stats;
}

/*═══════════════════════════════════════════════════════════════════════════
 * TEST: Gradient on Real Market Data
 *═══════════════════════════════════════════════════════════════════════════*/

static void test_gradient_on_market_data(const char* data_path, const char* name) {
    printf("\n═══════════════════════════════════════════════════════════════════\n");
    printf(" TEST: ν Gradient on %s\n", name);
    printf("═══════════════════════════════════════════════════════════════════\n\n");
    
    // Load data
    float* returns;
    int n;
    
    if (load_returns_binary(data_path, &returns, &n) != 0) {
        printf(" ERROR: Could not load %s\n", data_path);
        return;
    }
    
    print_return_stats(name, returns, n);
    
    // Auto-calibrate μ from realized volatility
    float filter_mu = estimate_mu_from_data(returns, n);
    float implied_vol = expf(filter_mu / 2.0f);
    
    // Fixed structural parameters (stable across equity data)
    const float filter_rho = 0.98f;      // Persistence ~0.97-0.99 for daily
    const float filter_sigma_z = 0.15f;  // Vol-of-vol ~0.10-0.20
    
    printf("\n Auto-calibrated: μ=%.2f → implied daily vol=%.2f%%\n", 
           filter_mu, implied_vol * 100.0f);
    printf(" Fixed params: ρ=%.2f, σ_z=%.2f\n", filter_rho, filter_sigma_z);
    printf(" Particles=%d, Stein=%d\n\n", DEFAULT_PARTICLES, DEFAULT_STEIN_STEPS);
    
    // Test different ν values
    printf("   ν_filter | Mean Grad  | Crash Grad | Calm Grad  | z²_mean | Crashes | Direction\n");
    printf("   ---------+------------+------------+------------+---------+---------+----------\n");
    
    float nu_values[] = {3.0f, 4.0f, 5.0f, 6.0f, 8.0f, 10.0f, 15.0f, 20.0f, 30.0f, 50.0f};
    int n_nu = sizeof(nu_values) / sizeof(nu_values[0]);
    
    float prev_grad = 1.0f;
    float equilibrium_nu = 0.0f;
    
    for (int i = 0; i < n_nu; i++) {
        float nu = nu_values[i];
        
        GradientStats stats = run_gradient_test(
            returns, n, nu, filter_mu, filter_rho, filter_sigma_z,
            DEFAULT_PARTICLES, DEFAULT_STEIN_STEPS
        );
        
        const char* direction;
        if (stats.mean_gradient > 0.001f) direction = "↑ increase";
        else if (stats.mean_gradient < -0.001f) direction = "↓ decrease";
        else direction = "≈ equilib";
        
        printf("   %7.1f  | %+10.6f | %+10.5f | %+10.6f | %7.3f | %5d   | %s\n",
               nu, stats.mean_gradient, stats.mean_grad_crash, 
               stats.mean_grad_calm, stats.mean_z_sq, stats.n_crashes, direction);
        
        // Detect zero crossing
        if (i > 0 && prev_grad > 0 && stats.mean_gradient < 0) {
            equilibrium_nu = (nu_values[i-1] + nu_values[i]) / 2.0f;
        }
        
        prev_grad = stats.mean_gradient;
    }
    
    printf("\n");
    if (equilibrium_nu > 0) {
        printf(" Equilibrium ν ≈ %.1f (gradient crosses zero)\n", equilibrium_nu);
    } else if (prev_grad > 0) {
        printf(" Equilibrium ν > 50 (gradient still positive)\n");
    } else {
        printf(" Equilibrium ν < 3 (gradient already negative at ν=3)\n");
    }
    
    free(returns);
}

/*═══════════════════════════════════════════════════════════════════════════
 * TEST: Compare Crash vs Calm Gradient Magnitude
 *═══════════════════════════════════════════════════════════════════════════*/

static void test_crash_vs_calm_gradient(const char* data_dir) {
    printf("\n═══════════════════════════════════════════════════════════════════\n");
    printf(" TEST: Crash vs Calm Gradient Magnitude\n");
    printf("═══════════════════════════════════════════════════════════════════\n\n");
    
    char path_spy_full[512], path_2008[512], path_2020[512], path_crashes[512], path_tsla[512];
    snprintf(path_spy_full, sizeof(path_spy_full), "%sspy_full.bin", data_dir);
    snprintf(path_2008, sizeof(path_2008), "%sspy_2008_crisis.bin", data_dir);
    snprintf(path_2020, sizeof(path_2020), "%sspy_2020_covid.bin", data_dir);
    snprintf(path_crashes, sizeof(path_crashes), "%scrashes_combined.bin", data_dir);
    snprintf(path_tsla, sizeof(path_tsla), "%stsla.bin", data_dir);
    
    const char* datasets[] = {
        path_spy_full,
        path_2008,
        path_2020,
        path_crashes,
        path_tsla
    };
    const char* names[] = {
        "SPY Full (2007-2024)",
        "SPY 2008 Crisis",
        "SPY 2020 COVID",
        "Crashes Combined",
        "TSLA (high vol)"
    };
    int n_datasets = sizeof(datasets) / sizeof(datasets[0]);
    
    const float filter_nu = 10.0f;  // Moderately heavy tails
    const float filter_rho = 0.98f;
    const float filter_sigma = 0.15f;
    
    printf(" Testing with ν=%.0f (μ auto-calibrated per dataset)\n\n", filter_nu);
    printf(" Dataset              | N      | μ_est  | Crashes | Crash Grad  | Calm Grad   | Ratio\n");
    printf(" ---------------------+--------+--------+---------+-------------+-------------+------\n");
    
    for (int d = 0; d < n_datasets; d++) {
        float* returns;
        int n;
        
        if (load_returns_binary(datasets[d], &returns, &n) != 0) {
            printf(" %-20s | ERROR loading\n", names[d]);
            continue;
        }
        
        // Auto-calibrate μ for this dataset
        float filter_mu = estimate_mu_from_data(returns, n);
        
        GradientStats stats = run_gradient_test(
            returns, n, filter_nu, filter_mu, filter_rho, filter_sigma,
            DEFAULT_PARTICLES, DEFAULT_STEIN_STEPS
        );
        
        float ratio = (stats.mean_grad_calm != 0) ? 
            fabsf(stats.mean_grad_crash / stats.mean_grad_calm) : 0.0f;
        
        printf(" %-20s | %6d | %6.2f | %7d | %+11.6f | %+11.6f | %5.1fx\n",
               names[d], n, filter_mu, stats.n_crashes, 
               stats.mean_grad_crash, stats.mean_grad_calm, ratio);
        
        free(returns);
    }
    
    printf("\n Key insight: Gradient magnitude should be much larger during crashes.\n");
    printf(" This confirms ν is only identifiable from tail events.\n");
}

/*═══════════════════════════════════════════════════════════════════════════
 * TEST: Gradient Time Series (for plotting)
 *═══════════════════════════════════════════════════════════════════════════*/

static void write_gradient_timeseries(const char* data_path, const char* output_path) {
    printf("\n═══════════════════════════════════════════════════════════════════\n");
    printf(" Writing gradient time series: %s\n", output_path);
    printf("═══════════════════════════════════════════════════════════════════\n");
    
    float* returns;
    int n;
    
    if (load_returns_binary(data_path, &returns, &n) != 0) {
        printf(" ERROR: Could not load %s\n", data_path);
        return;
    }
    
    FILE* f = fopen(output_path, "w");
    if (!f) {
        printf(" ERROR: Could not open %s for writing\n", output_path);
        free(returns);
        return;
    }
    
    fprintf(f, "t,return,vol_est,h_mean,z_sq,nu_grad_5,nu_grad_10,nu_grad_30\n");
    
    // Auto-calibrate μ for this dataset
    float filter_mu = estimate_mu_from_data(returns, n);
    printf(" Auto-calibrated μ=%.2f\n", filter_mu);
    
    // Create three filters with different ν
    SVPFState* state_5 = svpf_create(DEFAULT_PARTICLES, DEFAULT_STEIN_STEPS, 5.0f, nullptr);
    SVPFState* state_10 = svpf_create(DEFAULT_PARTICLES, DEFAULT_STEIN_STEPS, 10.0f, nullptr);
    SVPFState* state_30 = svpf_create(DEFAULT_PARTICLES, DEFAULT_STEIN_STEPS, 30.0f, nullptr);
    
    SVPFParams params = {0.98f, 0.15f, filter_mu, 0.0f};
    svpf_initialize(state_5, &params, 12345);
    svpf_initialize(state_10, &params, 12345);
    svpf_initialize(state_30, &params, 12345);
    
    float y_prev = 0.0f;
    for (int t = 0; t < n; t++) {
        float y_t = returns[t];
        
        float loglik, vol_5, h_5, vol_10, h_10, vol_30, h_30;
        svpf_step_graph(state_5, y_t, y_prev, &params, &loglik, &vol_5, &h_5);
        svpf_step_graph(state_10, y_t, y_prev, &params, &loglik, &vol_10, &h_10);
        svpf_step_graph(state_30, y_t, y_prev, &params, &loglik, &vol_30, &h_30);
        
        float nu_grad_5, z_sq_5, nu_grad_10, z_sq_10, nu_grad_30, z_sq_30;
        svpf_compute_nu_diagnostic_simple(state_5, y_t, &nu_grad_5, &z_sq_5);
        svpf_compute_nu_diagnostic_simple(state_10, y_t, &nu_grad_10, &z_sq_10);
        svpf_compute_nu_diagnostic_simple(state_30, y_t, &nu_grad_30, &z_sq_30);
        
        fprintf(f, "%d,%.8f,%.6f,%.4f,%.4f,%.8f,%.8f,%.8f\n",
                t, y_t, vol_10, h_10, z_sq_10, nu_grad_5, nu_grad_10, nu_grad_30);
        
        y_prev = y_t;
    }
    
    svpf_destroy(state_5);
    svpf_destroy(state_10);
    svpf_destroy(state_30);
    
    fclose(f);
    free(returns);
    
    printf(" Written %d rows to %s\n", n, output_path);
}

/*═══════════════════════════════════════════════════════════════════════════
 * MAIN
 *═══════════════════════════════════════════════════════════════════════════*/

int main(int argc, char** argv) {
    printf("\n");
    printf("╔═══════════════════════════════════════════════════════════════════╗\n");
    printf("║     SVPF Gradient Diagnostic - Real Market Data                   ║\n");
    printf("║     Testing on actual crashes (2008, 2020, etc.)                  ║\n");
    printf("╚═══════════════════════════════════════════════════════════════════╝\n");
    
    // Find data directory
    const char* data_dir = find_data_path();
    if (!data_dir) {
        printf("\n ERROR: Could not find market_data directory!\n");
        printf(" Tried paths:\n");
        for (int i = 0; DATA_PATHS[i] != NULL; i++) {
            printf("   - %s\n", DATA_PATHS[i]);
        }
        printf("\n Make sure to run: python scripts/fetch_market_data.py\n");
        printf(" And that market_data/ is at the project root.\n");
        return 1;
    }
    printf("\n Found market data at: %s\n", data_dir);
    
    // Build full paths
    char path_spy_full[512], path_2008[512], path_2020[512], path_crashes[512];
    snprintf(path_spy_full, sizeof(path_spy_full), "%sspy_full.bin", data_dir);
    snprintf(path_2008, sizeof(path_2008), "%sspy_2008_crisis.bin", data_dir);
    snprintf(path_2020, sizeof(path_2020), "%sspy_2020_covid.bin", data_dir);
    snprintf(path_crashes, sizeof(path_crashes), "%scrashes_combined.bin", data_dir);
    
    // Test on different datasets
    test_gradient_on_market_data(path_spy_full, "SPY Full (2007-2024)");
    test_gradient_on_market_data(path_2008, "SPY 2008 Crisis");
    test_gradient_on_market_data(path_2020, "SPY 2020 COVID");
    test_gradient_on_market_data(path_crashes, "Crashes Combined");
    
    // Compare crash vs calm
    test_crash_vs_calm_gradient(data_dir);
    
    // Optional: Write time series for plotting
    if (argc > 1 && strcmp(argv[1], "--timeseries") == 0) {
        const char* output = (argc > 2) ? argv[2] : "gradient_timeseries.csv";
        write_gradient_timeseries(path_2008, output);
    }
    
    printf("\n═══════════════════════════════════════════════════════════════════\n");
    printf(" Summary\n");
    printf("═══════════════════════════════════════════════════════════════════\n");
    printf("\n");
    printf(" Expected observations on real market data:\n");
    printf("   - More tail events (z²>9) than synthetic DGP\n");
    printf("   - Gradient much larger during crashes\n");
    printf("   - Equilibrium ν lower (real data has fatter tails)\n");
    printf("   - 2008 and 2020 should show strongest gradient signal\n");
    printf("\n");
    
    return 0;
}
