/**
 * @file test_svpf_gradient_market.cu
 * @brief Gradient diagnostic on REAL market data
 *
 * Purpose: Verify ν gradient behavior on actual market crashes where
 *          the DGP synthetic scenarios showed insufficient tail events.
 *
 * Key hypothesis:
 *   - Real crashes (2008, 2020) have genuine fat tails
 *   - ν gradient should be much more informative during these periods
 *   - Equilibrium ν should be lower than on synthetic data
 *
 * Data files (generated by scripts/fetch_market_data.py):
 *   - market_data/spy_full.bin          (4528 obs, 2007-2024)
 *   - market_data/spy_2008_crisis.bin   (375 obs)
 *   - market_data/spy_2020_covid.bin    (123 obs)
 *   - market_data/crashes_combined.bin  (706 obs, all crash periods)
 */

#include "svpf.cuh"
#include "market_data_loader.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

/*═══════════════════════════════════════════════════════════════════════════
 * CONFIGURATION
 *═══════════════════════════════════════════════════════════════════════════*/

// Default paths (relative to build directory)
#define DATA_DIR "../market_data/"

// Filter configuration
#define DEFAULT_PARTICLES    4096
#define DEFAULT_STEIN_STEPS  5

/*═══════════════════════════════════════════════════════════════════════════
 * TEST UTILITIES
 *═══════════════════════════════════════════════════════════════════════════*/

typedef struct {
    float mean_gradient;
    float mean_z_sq;
    int n_crashes;          // z² > 9
    float mean_grad_crash;  // Gradient during crashes
    float mean_grad_calm;   // Gradient during calm
    float rmse_vol;         // RMSE vs realized vol
    int n_obs;
} GradientStats;

static GradientStats run_gradient_test(
    const float* returns,
    int n,
    float filter_nu,
    float filter_mu,
    float filter_rho,
    float filter_sigma_z,
    int n_particles,
    int n_stein_steps
) {
    GradientStats stats = {0};
    stats.n_obs = n;
    
    // Create filter
    SVPFState* state = svpf_create(n_particles, n_stein_steps, filter_nu, nullptr);
    SVPFParams params = {filter_rho, filter_sigma_z, filter_mu, 0.0f};
    svpf_initialize(state, &params, 12345);
    
    // Accumulators
    double grad_sum = 0, z_sq_sum = 0;
    double grad_crash_sum = 0, grad_calm_sum = 0;
    int n_crash = 0, n_calm = 0;
    double vol_sq_err_sum = 0;
    
    // Estimate realized vol with EMA
    float realized_vol = fabsf(returns[0]);
    const float vol_ema_alpha = 0.1f;
    
    float y_prev = 0.0f;
    for (int t = 0; t < n; t++) {
        float y_t = returns[t];
        
        // Update realized vol estimate
        realized_vol = (1.0f - vol_ema_alpha) * realized_vol + vol_ema_alpha * fabsf(y_t);
        
        // SVPF step
        float loglik, vol_est, h_mean;
        svpf_step_graph(state, y_t, y_prev, &params, &loglik, &vol_est, &h_mean);
        
        // Gradient diagnostic
        float nu_grad, z_sq;
        svpf_compute_nu_diagnostic_simple(state, y_t, &nu_grad, &z_sq);
        
        // Accumulate
        if (!isnan(nu_grad) && !isinf(nu_grad)) {
            grad_sum += nu_grad;
            z_sq_sum += z_sq;
            
            if (z_sq > 9.0f) {
                grad_crash_sum += nu_grad;
                n_crash++;
            } else {
                grad_calm_sum += nu_grad;
                n_calm++;
            }
        }
        
        // Vol error
        float vol_err = vol_est - realized_vol;
        vol_sq_err_sum += vol_err * vol_err;
        
        y_prev = y_t;
    }
    
    svpf_destroy(state);
    
    // Compute stats
    stats.mean_gradient = (float)(grad_sum / n);
    stats.mean_z_sq = (float)(z_sq_sum / n);
    stats.n_crashes = n_crash;
    stats.mean_grad_crash = (n_crash > 0) ? (float)(grad_crash_sum / n_crash) : 0.0f;
    stats.mean_grad_calm = (n_calm > 0) ? (float)(grad_calm_sum / n_calm) : 0.0f;
    stats.rmse_vol = sqrtf((float)(vol_sq_err_sum / n));
    
    return stats;
}

/*═══════════════════════════════════════════════════════════════════════════
 * TEST: Gradient on Real Market Data
 *═══════════════════════════════════════════════════════════════════════════*/

static void test_gradient_on_market_data(const char* data_path, const char* name) {
    printf("\n═══════════════════════════════════════════════════════════════════\n");
    printf(" TEST: ν Gradient on %s\n", name);
    printf("═══════════════════════════════════════════════════════════════════\n\n");
    
    // Load data
    float* returns;
    int n;
    
    if (load_returns_binary(data_path, &returns, &n) != 0) {
        printf(" ERROR: Could not load %s\n", data_path);
        return;
    }
    
    print_return_stats(name, returns, n);
    printf("\n");
    
    // Fixed filter params (reasonable defaults for equity returns)
    const float filter_mu = -4.5f;       // log(0.01) ≈ -4.6 for 1% daily vol
    const float filter_rho = 0.97f;      // Typical persistence
    const float filter_sigma_z = 0.15f;  // Vol-of-vol
    
    printf(" Filter config: μ=%.2f, ρ=%.2f, σ_z=%.2f\n", 
           filter_mu, filter_rho, filter_sigma_z);
    printf(" Particles=%d, Stein=%d\n\n", DEFAULT_PARTICLES, DEFAULT_STEIN_STEPS);
    
    // Test different ν values
    printf("   ν_filter | Mean Grad  | Crash Grad | Calm Grad  | z²_mean | Crashes | Direction\n");
    printf("   ---------+------------+------------+------------+---------+---------+----------\n");
    
    float nu_values[] = {3.0f, 4.0f, 5.0f, 6.0f, 8.0f, 10.0f, 15.0f, 20.0f, 30.0f, 50.0f};
    int n_nu = sizeof(nu_values) / sizeof(nu_values[0]);
    
    float prev_grad = 1.0f;
    float equilibrium_nu = 0.0f;
    
    for (int i = 0; i < n_nu; i++) {
        float nu = nu_values[i];
        
        GradientStats stats = run_gradient_test(
            returns, n, nu, filter_mu, filter_rho, filter_sigma_z,
            DEFAULT_PARTICLES, DEFAULT_STEIN_STEPS
        );
        
        const char* direction;
        if (stats.mean_gradient > 0.001f) direction = "↑ increase";
        else if (stats.mean_gradient < -0.001f) direction = "↓ decrease";
        else direction = "≈ equilib";
        
        printf("   %7.1f  | %+10.6f | %+10.5f | %+10.6f | %7.3f | %5d   | %s\n",
               nu, stats.mean_gradient, stats.mean_grad_crash, 
               stats.mean_grad_calm, stats.mean_z_sq, stats.n_crashes, direction);
        
        // Detect zero crossing
        if (i > 0 && prev_grad > 0 && stats.mean_gradient < 0) {
            equilibrium_nu = (nu_values[i-1] + nu_values[i]) / 2.0f;
        }
        
        prev_grad = stats.mean_gradient;
    }
    
    printf("\n");
    if (equilibrium_nu > 0) {
        printf(" Equilibrium ν ≈ %.1f (gradient crosses zero)\n", equilibrium_nu);
    } else if (prev_grad > 0) {
        printf(" Equilibrium ν > 50 (gradient still positive)\n");
    } else {
        printf(" Equilibrium ν < 3 (gradient already negative at ν=3)\n");
    }
    
    free(returns);
}

/*═══════════════════════════════════════════════════════════════════════════
 * TEST: Compare Crash vs Calm Gradient Magnitude
 *═══════════════════════════════════════════════════════════════════════════*/

static void test_crash_vs_calm_gradient(void) {
    printf("\n═══════════════════════════════════════════════════════════════════\n");
    printf(" TEST: Crash vs Calm Gradient Magnitude\n");
    printf("═══════════════════════════════════════════════════════════════════\n\n");
    
    const char* datasets[] = {
        DATA_DIR "spy_full.bin",
        DATA_DIR "spy_2008_crisis.bin",
        DATA_DIR "spy_2020_covid.bin",
        DATA_DIR "crashes_combined.bin",
        DATA_DIR "tsla.bin"
    };
    const char* names[] = {
        "SPY Full (2007-2024)",
        "SPY 2008 Crisis",
        "SPY 2020 COVID",
        "Crashes Combined",
        "TSLA (high vol)"
    };
    int n_datasets = sizeof(datasets) / sizeof(datasets[0]);
    
    const float filter_nu = 10.0f;  // Moderately heavy tails
    
    printf(" Testing with ν=%0.f\n\n", filter_nu);
    printf(" Dataset              | N      | Crashes | Crash Grad  | Calm Grad   | Ratio\n");
    printf(" ---------------------+--------+---------+-------------+-------------+------\n");
    
    for (int d = 0; d < n_datasets; d++) {
        float* returns;
        int n;
        
        if (load_returns_binary(datasets[d], &returns, &n) != 0) {
            printf(" %-20s | ERROR loading\n", names[d]);
            continue;
        }
        
        GradientStats stats = run_gradient_test(
            returns, n, filter_nu, -4.5f, 0.97f, 0.15f,
            DEFAULT_PARTICLES, DEFAULT_STEIN_STEPS
        );
        
        float ratio = (stats.mean_grad_calm != 0) ? 
            fabsf(stats.mean_grad_crash / stats.mean_grad_calm) : 0.0f;
        
        printf(" %-20s | %6d | %7d | %+11.6f | %+11.6f | %5.1fx\n",
               names[d], n, stats.n_crashes, 
               stats.mean_grad_crash, stats.mean_grad_calm, ratio);
        
        free(returns);
    }
    
    printf("\n Key insight: Gradient magnitude should be much larger during crashes.\n");
    printf(" This confirms ν is only identifiable from tail events.\n");
}

/*═══════════════════════════════════════════════════════════════════════════
 * TEST: Gradient Time Series (for plotting)
 *═══════════════════════════════════════════════════════════════════════════*/

static void write_gradient_timeseries(const char* data_path, const char* output_path) {
    printf("\n═══════════════════════════════════════════════════════════════════\n");
    printf(" Writing gradient time series: %s\n", output_path);
    printf("═══════════════════════════════════════════════════════════════════\n");
    
    float* returns;
    int n;
    
    if (load_returns_binary(data_path, &returns, &n) != 0) {
        printf(" ERROR: Could not load %s\n", data_path);
        return;
    }
    
    FILE* f = fopen(output_path, "w");
    if (!f) {
        printf(" ERROR: Could not open %s for writing\n", output_path);
        free(returns);
        return;
    }
    
    fprintf(f, "t,return,vol_est,h_mean,z_sq,nu_grad_5,nu_grad_10,nu_grad_30\n");
    
    // Create three filters with different ν
    SVPFState* state_5 = svpf_create(DEFAULT_PARTICLES, DEFAULT_STEIN_STEPS, 5.0f, nullptr);
    SVPFState* state_10 = svpf_create(DEFAULT_PARTICLES, DEFAULT_STEIN_STEPS, 10.0f, nullptr);
    SVPFState* state_30 = svpf_create(DEFAULT_PARTICLES, DEFAULT_STEIN_STEPS, 30.0f, nullptr);
    
    SVPFParams params = {0.97f, 0.15f, -4.5f, 0.0f};
    svpf_initialize(state_5, &params, 12345);
    svpf_initialize(state_10, &params, 12345);
    svpf_initialize(state_30, &params, 12345);
    
    float y_prev = 0.0f;
    for (int t = 0; t < n; t++) {
        float y_t = returns[t];
        
        float loglik, vol_5, h_5, vol_10, h_10, vol_30, h_30;
        svpf_step_graph(state_5, y_t, y_prev, &params, &loglik, &vol_5, &h_5);
        svpf_step_graph(state_10, y_t, y_prev, &params, &loglik, &vol_10, &h_10);
        svpf_step_graph(state_30, y_t, y_prev, &params, &loglik, &vol_30, &h_30);
        
        float nu_grad_5, z_sq_5, nu_grad_10, z_sq_10, nu_grad_30, z_sq_30;
        svpf_compute_nu_diagnostic_simple(state_5, y_t, &nu_grad_5, &z_sq_5);
        svpf_compute_nu_diagnostic_simple(state_10, y_t, &nu_grad_10, &z_sq_10);
        svpf_compute_nu_diagnostic_simple(state_30, y_t, &nu_grad_30, &z_sq_30);
        
        fprintf(f, "%d,%.8f,%.6f,%.4f,%.4f,%.8f,%.8f,%.8f\n",
                t, y_t, vol_10, h_10, z_sq_10, nu_grad_5, nu_grad_10, nu_grad_30);
        
        y_prev = y_t;
    }
    
    svpf_destroy(state_5);
    svpf_destroy(state_10);
    svpf_destroy(state_30);
    
    fclose(f);
    free(returns);
    
    printf(" Written %d rows to %s\n", n, output_path);
}

/*═══════════════════════════════════════════════════════════════════════════
 * MAIN
 *═══════════════════════════════════════════════════════════════════════════*/

int main(int argc, char** argv) {
    printf("\n");
    printf("╔═══════════════════════════════════════════════════════════════════╗\n");
    printf("║     SVPF Gradient Diagnostic - Real Market Data                   ║\n");
    printf("║     Testing on actual crashes (2008, 2020, etc.)                  ║\n");
    printf("╚═══════════════════════════════════════════════════════════════════╝\n");
    
    // Test on different datasets
    test_gradient_on_market_data(DATA_DIR "spy_full.bin", "SPY Full (2007-2024)");
    test_gradient_on_market_data(DATA_DIR "spy_2008_crisis.bin", "SPY 2008 Crisis");
    test_gradient_on_market_data(DATA_DIR "spy_2020_covid.bin", "SPY 2020 COVID");
    test_gradient_on_market_data(DATA_DIR "crashes_combined.bin", "Crashes Combined");
    
    // Compare crash vs calm
    test_crash_vs_calm_gradient();
    
    // Optional: Write time series for plotting
    if (argc > 1 && strcmp(argv[1], "--timeseries") == 0) {
        const char* output = (argc > 2) ? argv[2] : "gradient_timeseries.csv";
        write_gradient_timeseries(DATA_DIR "spy_2008_crisis.bin", output);
    }
    
    printf("\n═══════════════════════════════════════════════════════════════════\n");
    printf(" Summary\n");
    printf("═══════════════════════════════════════════════════════════════════\n");
    printf("\n");
    printf(" Expected observations on real market data:\n");
    printf("   - More tail events (z²>9) than synthetic DGP\n");
    printf("   - Gradient much larger during crashes\n");
    printf("   - Equilibrium ν lower (real data has fatter tails)\n");
    printf("   - 2008 and 2020 should show strongest gradient signal\n");
    printf("\n");
    
    return 0;
}
